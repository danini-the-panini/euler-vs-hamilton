Euler vs Hamilton
=================

Introduction
------------

This program is to aid the investigation on the differences in numerical stability between Euler angles and Hamilton`s quaternions when doing rotations.

We will do so by building a program that provides a camera for navigating a 3D scene. This camera will have six degrees of freedom, which should expose some of the flaws of Euler angles, sauch as gimbal lock and the lack of smooth transitions.

All maths is provided generously by [glm](http://glm.g-truc.net/).

  <{ Main }>=
    <{ Euler vs Hamilton }>

Top level program layout
------------------------

In our program we will define a few mathematical constructs to aid us in our calculations. Thereafter we will define the object representing the camera.

We will also define a number of functions for manipulating this camera. There will be two sets of functions, one set using Euler angles, and the other set using quaternions.

Finally, we will define the body of our application.

  <{ Euler vs Hamilton }>=
    <{ Includes }>
    <{ Camera }>
    <{ Euler Rotations }>
    <{ Quaternion Rotations }>
    <{ Application }>

The Camera
----------

The camera is defined with three vectors: eye, at and up. Eye is a point vector defines the location of the center of the camera. At is a point vector defining where the camera is looking. Up is a direction vector defining which way is up in the view.

The structure (and all future structures and functions) is templatized to allow us to switch between single and double floating point precision. This is to aid the comparison of numerical stability.

  <{ Camera }>=
    
    template< typename T >
    struct Camera
    {
      tvec3<T> eye;
      tvec3<T> at;
      tvec3<T> up;
    };

Euler, the buff maths guy
-------------------------

Here we are simply using the standard rotate function from glm.

  <{ Euler Rotations }>=

    template< typename T >
    tmat4x4<T> euler_rotate(T angle, tvec3<T> axis)
    {
      return rotate(tmat4x4<T>(1.0), angle, normalize(axis));
    }

Dat Hamilton
------------

Here we use the quaternion glm extention. Its rotation function is similar to the one above.

  <{ Quaternion Rotations }>=

    template< typename T >
    tmat4x4<T> quaternion_rotate(T angle, tvec3<T> axis)
    {
      tquat<T> q = rotate(tquat<T>(1,0,0,0), angle, normalize(axis));

      return mat4_cast(q);
    }

She`s my main squeeze
---------------------

Here we will define the entrace point to our C++ application. I`ve simply grabbed the [GLWF](http://www.glfw.org/) example code from [here](http://www.glfw.org/documentation.html) and built on it.

  <{ Application }>=

    int main()
    {
      <{ Constants }>
      <{ Variables }>

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "Euler vs Hamilton", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);

      glewExperimental = GL_TRUE; 
      glewInit();

      <{ Setup }>

      /* Loop until the user closes the window */
      while (!glfwWindowShouldClose(window))
      {
          <{ Render Scene}>

          /* Swap front and back buffers */
          glfwSwapBuffers(window);

          /* Poll for and process events */
          glfwPollEvents();
      }

      glfwTerminate();
      return 0;
    }

Constant[inople]s
-----------------

Here are some constants we will be needing for our application.

  <{ Constants }>=

    const float fovy = 45.0f;
    const float near = 1.f;
    const float far = 100.0f;

Some Variables
--------------

We will need a window, and a camera.

  <{ Variables }>=

    GLFWwindow* window;
    Camera<float> camera;

Setting things up
-----------------

For starters, we will create our camera object and set the background colour.

  <{ Setup }>=

    camera.eye = vec3(2,2,2);
    camera.at = vec3(0,0,0);
    camera.up = vec3(0,1,0);

    glClearColor(1,1,1,1);


What are we looking at?
-----------------------

To have something to look at, we will draw a simple quad.

### Creating the quad

The quad is defined as a simple VAO.

  <{ Quad }>=


    int i = 0;

    verts[i++] = 0.0f;
    verts[i++] = 0.0f;
    verts[i++] = 0.0f;

    verts[i++] = 1.0f;
    verts[i++] = 0.0f;
    verts[i++] = 0.0f;

    verts[i++] = 1.0f;
    verts[i++] = 0.0f;
    verts[i++] = 1.0f;

    verts[i++] = 0.0f;
    verts[i++] = 0.0f;
    verts[i++] = 1.0f;


    i = 0;

    faces[i++] = 0;
    faces[i++] = 2;
    faces[i++] = 1;

    faces[i++] = 0;
    faces[i++] = 3;
    faces[i++] = 2;

    glGenVertexArrays(1, &quad);
    glBindVertexArray(quad);

    GLuint ptr;
    glGenBuffers(1, &ptr);
    glBindBuffer(GL_ARRAY_BUFFER, ptr);

    glBufferData(GL_ARRAY_BUFFER, VERTEX_ARRAY_SIZE * sizeof(float),
            verts, GL_STATIC_DRAW);

    glGenBuffers(1, &ptr);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ptr);

    glBufferData(GL_ELEMENT_ARRAY_BUFFER, NUM_FACES * sizeof(GLuint),
            faces, GL_STATIC_DRAW);

    glEnableVertexAttribArray(POSITION_LOC);
    glVertexAttribPointer(POSITION_LOC, VERTEX_SIZE, GL_FLOAT, GL_FALSE,
            VERTEX_SIZE * sizeof(float), 0);

### And making sure it gets created

  <{ Setup }>+=

    <{ Quad }>

Some more constants
-------------------

For the quad, we will need to define some of those constants we used.

  <{ Constants }>+=

    const GLuint VERTEX_SIZE = 3;
    const GLuint NUM_VERTICES = 4;
    const GLuint VERTEX_ARRAY_SIZE = NUM_VERTICES * VERTEX_SIZE;
    const GLuint NUM_FACES = 2;
    const GLuint FACE_SIZE = 3;
    const GLuint INDEX_ARRAY_SIZE = NUM_FACES * FACE_SIZE;
    const GLuint POSITION_LOC = 1;


Get a handle on things
----------------------

We will also need to define the handle we use for the quad VAO, as well as the arrays containing the vertex data.

  <{ Variables }>+=

    GLuint quad = 0;

    float* verts = new float[VERTEX_ARRAY_SIZE];
    float* faces = new float[INDEX_ARRAY_SIZE];

Make everything visible!
------------------------

### Top level render sequence

This is how the rendering will play out, on a high level.

  <{ Render Scene }>=

    <{ Clear Scene }>
    <{ Set up Camera }>
    <{ Draw Quad }>

### Starting fresh

Before we draw anything, we will clear the screen.

  <{ Clear Scene }>=
    glfwGetFramebufferSize(window, &width, &height);
    glViewport(0, 0, width, height);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

### For the last time, it is not spelled 'heighth'

We will need to define the variables holding width and height.

  <{ Variables }>+=

    int width = 0;
    int height = 0;

### Setting up the tripod

  <{ Set up Camera }>=

    float ratio = (float) width / (float) height;
    mat4 view = lookAt(camera.eye, camera.at, camera.up);
    mat4 projection = perspective(fovy, ratio, near, far);

    glUniformMatrix4fv(view_location, 1, GL_FALSE, value_ptr(view));
    glUniformMatrix4fv(projection_location, 1, GL_FALSE, value_ptr(projection));

### Drawing the quad

This is the point where we actually put the quad on the screen.

  <{ Draw Quad }>=

    glUniformMatrix4fv(world_location, 1, GL_FALSE, value_ptr(world));

    glBindVertexArray(quad);
    glDrawElements(GL_TRIANGLES, (GLsizei)NUM_FACES, GL_UNSIGNED_INT, 0);

### The world matrix

  <{ Variables }>+=

    mat4 world(1);

  <{ Setup }>+=

    world = scale(world, vec3(10,10,10));

We are gonna need some shaders
------------------------------

### Loading the shader

  <{ Variables }>+=
    GLuint shader_program = 0;
    GLint view_location = 0;
    GLint projection_location = 0;
    GLint world_location = 0;

  <{ Shaders }>=
    shader_program = glCreateProgram();

    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex_shader, 1, &vertex_glsl, NULL);
    glCompileShader(vertex_shader);
    shaderLog(vertex_shader);

    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment_shader, 1, &fragment_glsl, NULL);
    glCompileShader(fragment_shader);
    shaderLog(fragment_shader);

    glAttachShader(shader_program, vertex_shader);
    glAttachShader(shader_program, fragment_shader);

    glLinkProgram(shader_program);
    programLog(shader_program);

    glUseProgram(shader_program);

    view_location = glGetUniformLocation(shader_program, "view");
    projection_location = glGetUniformLocation(shader_program, "projection");
    world_location = glGetUniformLocation(shader_program, "world");

### The actuals shaders

  <{ Constants }>+=

    const char *vertex_glsl = 
      "#version 430\n"

      "uniform mat4 view;\n"
      "uniform mat4 projection;\n"
      "uniform mat4 world;\n"

      "layout (location=1) in vec3 position;\n"

      "void main()\n"
      "{\n"
        "gl_Position = projection * view * world * vec4(position,1.0f);\n"
      "}\n";

    const char *fragment_glsl =
      "#version 430\n"

      "layout (location = 0) out vec4 colour;\n"

      "void main()\n"
      "{\n"
        "colour = vec4(1,0,1,1);\n"
      "}\n";

### Now add that to the Setup

  <{ Setup }>+=
    <{ Shaders }>

Include all the things
----------------------

  <{ Includes }>=
    #include <cmath>
    #include <cstdlib>
    #include <GL/glew.h>
    #include <GLFW/glfw3.h>
    #include <glm/glm.hpp>
    #include <glm/gtc/matrix_transform.hpp>
    #include <glm/gtc/type_ptr.hpp>
    #include <glm/gtc/quaternion.hpp>
    #include <iostream>

    using glm::detail::tmat4x4;
    using glm::detail::tquat;
    using glm::detail::tvec3;
    using glm::lookAt;
    using glm::mat4;
    using glm::perspective;
    using glm::rotate;
    using glm::scale;
    using glm::value_ptr;
    using glm::vec3;

    using std::cerr;
    using std::cout;
    using std::endl;

    // Just some helper functions for checking shaders...
    void shaderLog(GLuint handle)
    {
      int status;
      glGetShaderiv(handle, GL_COMPILE_STATUS, &status);

      if (status == GL_FALSE)
      {
         /* Get the length of the info log. */
         int len;
         glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &len);

         /* Get the info log. */
         char* log = new char[len];
         glGetShaderInfoLog(handle, len, &len, log);

         /* Print error */
         cerr << "Compilation error: " << log << endl;

         /* Finally, free the memory allocated. */
         delete log;

         /* Exit the program. */
         exit(-1);
      }
    }
    void programLog(GLuint handle)
    {
      int status;
      glGetProgramiv(handle, GL_LINK_STATUS, &status);

      if (status == GL_FALSE)
      {
         /* Get the length of the info log. */
         int len;
         glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &len);

         /* Get the info log. */
         char* log = new char[len];
         glGetProgramInfoLog(handle, len, &len, log);

         /* Print error */
         cerr << "Link error: " << log << endl;

         /* Finally, free the memory allocated. */
         delete log;

         /* Exit the program. */
         exit(-1);
      }
    }